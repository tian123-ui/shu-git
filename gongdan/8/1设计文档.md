#### 一、项目背景

在电商行业竞争白热化的背景下，商家对 “精准营销” 的需求愈发迫切。客服专属优惠作为客服场景的核心转化工具（支持立减、叠加优惠、不计入最低价），其效果直接影响询单转化率与店铺销量。



传统营销存在 “无差别优惠” 的痛点：高价值用户未被深度激活、流失用户未被有效召回，导致优惠资源浪费。为此，本项目通过构建 RFM 客户价值模型实现用户分层，结合客服专属优惠的业务特性，设计差异化营销策略，最终实现 “精准触达、资源优化、转化提升” 的目标。

#### 二、设计目标

1. **用户分层**：基于 RFM 模型将用户分为 “高价值用户、潜力用户、一般用户、流失用户”，量化用户价值。
2. **效果分析**：实现客服专属优惠活动的多维度分析（不分层整体指标 + 分层精细化指标）。
3. **指标体系**：覆盖活动效果、客服绩效、用户转化等核心指标，支持时间 / 活动 / 客服多维度下钻。
4. **数据可靠**：通过测试验证 RFM 分层逻辑及指标一致性，确保数据准确性。
5. **策略落地**：针对不同分层用户提供可执行的客服专属优惠策略，提升核销率与销量。
6. **流程闭环**：搭建 “数据生成 - 处理 - 建模 - 指标输出 - 策略应用” 的完整流程，支持复用与扩展。

#### 三、技术架构

采用 “数仓分层 + PySpark 大数据处理 + Pandas 精细化分析” 的技术栈，实现从数据到决策的全链路支撑。



|层级|核心工具|功能描述|关键文件|
|---|---|---|---|
|数据生成层|Python 随机数|生成模拟业务数据（活动、发送、核销、商品等），模拟真实业务场景|`ods_csv.py`、`dws_csv.py`|
|数据存储层|CSV 文件|轻量存储原始数据与中间结果，便于调试与共享|-|
|数据处理层|PySpark|处理大规模数据（清洗、关联、聚合），支撑数仓分层计算|`dim_csv.py`、`dwd_csv.py`|
|模型构建层|PySpark+Pandas|计算 RFM 指标并实现用户分层，输出分层结果|`fen_bu.py`、`ads.py`|
|指标计算层|SparkSQL|计算不分层 / 分层的活动效果、客服绩效等指标|`fen_bu.py`|
|测试验证层|PyTest 思想|验证分层逻辑与指标一致性，确保数据可靠|`test.py`|
|结果展示层|CSV 输出|输出直观的指标结果，支撑商家决策|-|

#### 四、数据分层与流程

采用数仓分层设计，实现数据 “从原始到应用” 的有序流转，每层职责清晰、数据可追溯。

##### （一）数据分层详情

|分层|名称|核心功能|输入数据|输出数据|
|---|---|---|---|---|
|ODS|操作数据层|存储原始业务数据，保留数据原貌（未清洗）|模拟生成的活动、发送、核销等数据|活动表、优惠发送表、核销表、商品表、客服表（原始 CSV）|
|DIM|维度层|构建静态维度表，补充描述性信息，支撑业务分析|ODS 层原始数据|商品维度表（商品 ID、名称、类别）、客服维度表（客服 ID、姓名、所属店铺）等|
|DWD|明细数据层|清洗转换原始数据（处理缺失值、格式转换），生成明细事实表|ODS 层数据 + DIM 层维度表|活动明细事实表、优惠发送明细事实表（含客服 / 用户 / 商品关联）、核销明细事实表|
|DWS|汇总数据层|按时间（日 / 7 天 / 30 天）、活动、客服等维度聚合，生成中间指标|DWD 层明细数据|每日汇总表（发送 / 核销次数）、活动汇总表（核销率）、客服绩效汇总表|
|ADS|应用数据层|基于 RFM 分层结果，输出最终指标与用户分层表，支撑业务决策|DWS 层汇总数据 + RFM 分层结果|客户分层表、优惠效果总览表（分层 / 不分层）、活动效果排名表|

##### （二）数据流程

1. **数据生成**：通过`ods_csv.py`和`dws_csv.py`生成模拟数据（如活动时间、优惠金额、核销记录等），存入 ODS 层。
2. **维度构建**：`dim_csv.py`从 ODS 层提取静态信息（如商品名称、客服姓名），生成 DIM 层维度表。
3. **明细处理**：`dwd_csv.py`清洗 ODS 数据（如补全缺失的用户 ID、转换时间格式），关联 DIM 表补充维度信息，生成 DWD 明细事实表。
4. **汇总计算**：`dws_csv.py`对 DWD 数据按时间 / 活动 / 客服聚合，计算发送次数、核销次数等中间指标，存入 DWS 层。
5. **RFM 建模**：`fen_bu.py`和`ads.py`基于 DWD 层数据计算 RFM 指标，对用户分层。
6. **指标输出**：基于 DWS 层数据和 RFM 分层结果，计算最终指标（不分层 / 分层），存入 ADS 层。
7. **测试验证**：`test.py`验证指标一致性与分层逻辑，确保数据可靠。
8. **结果应用**：ADS 层指标输出为 CSV，支撑商家制定营销策略。

#### 五、RFM 模型构建

通过 “最近消费时间（R）、消费频率（F）、消费金额（M）” 三维度量化用户价值，结合客服专属优惠场景定义如下：

##### （一）RFM 维度定义

|维度|定义（客服专属优惠场景）|业务意义|
|---|---|---|
|Recency（R）|用户最近一次使用客服专属优惠核销的时间距今天数（如 “3 天前” 记为 3）|反映用户活跃度，值越小越活跃|
|Frequency（F）|统计周期内用户使用客服专属优惠的核销次数（如 “5 次”）|反映用户对优惠的依赖度|
|Monetary（M）|统计周期内用户通过客服专属优惠核销的总支付金额（如 “1000 元”）|反映用户消费能力|

##### （二）打分与分层规则

1. **打分规则**（1-5 分，分数越高价值越高）：

   |维度|打分标准（示例）|
       |---|---|
   |R|≤7 天→5 分；8-30 天→4 分；31-90 天→3 分；91-180 天→2 分；＞180 天→1 分|
   |F|≥10 次→5 分；5-9 次→4 分；3-4 次→3 分；1-2 次→2 分；0 次→1 分|
   |M|≥10000 元→5 分；5000-9999 元→4 分；1000-4999 元→3 分；100-999 元→2 分；＜100 元→1 分|

2. **分层标准**（基于 R+F+M 总分）：

   |总分范围|用户分层|特征描述|
       |---|---|---|
   |＞12 分|高价值用户|最近消费、高频、高金额，是核心利润来源|
   |9-12 分|潜力用户|消费能力强但频率 / 活跃度低，有提升空间|
   |6-8 分|一般用户|消费中等，需刺激提升频率或金额|
   |≤5 分|流失用户|长期未消费、低频、低金额，需召回|


##### （三）代码实现（核心逻辑）

python

```python
def calculate_rfm_layer(spark, send_df, use_df):
    # 关联优惠发送与核销数据，获取用户消费行为
    user_behavior = send_df.join(use_df, on="send_id", how="left")
    
    # 计算RFM指标（以当前时间为基准）
    current_date = datetime.now().date()
    rfm_base = user_behavior.groupBy("consumer_id").agg(
        # R：最近消费距今天数（未核销用户默认999天）
        datediff(lit(current_date), max("pay_time")).alias("R").fillna(999),
        # F：核销次数（未核销用户为0）
        count(when(col("is_used") == "是", "send_id")).alias("F").fillna(0),
        # M：总支付金额（未核销用户为0）
        sum("pay_amount").alias("M").fillna(0)
    )
    
    # RFM打分
    r_score = when(col("R") <=7, 5).when(col("R") <=30, 4).when(col("R") <=90, 3).when(col("R") <=180, 2).otherwise(1)
    f_score = when(col("F") >=10, 5).when(col("F") >=5, 4).when(col("F") >=3, 3).when(col("F") >=1, 2).otherwise(1)
    m_score = when(col("M") >=10000, 5).when(col("M") >=5000, 4).when(col("M") >=1000, 3).when(col("M") >=100, 2).otherwise(1)
    
    # 计算总分并分层
    rfm_with_score = rfm_base.withColumn("R_score", r_score)\
                             .withColumn("F_score", f_score)\
                             .withColumn("M_score", m_score)\
                             .withColumn("rfm_total", col("R_score") + col("F_score") + col("M_score"))
    
    # 用户分层
    user_level = when(col("rfm_total") >12, "高价值用户")\
                 .when(col("rfm_total") >8, "潜力用户")\
                 .when(col("rfm_total") >5, "一般用户")\
                 .otherwise("流失用户")
    
    return rfm_with_score.withColumn("user_level", user_level)
```

#### 六、核心指标计算

指标体系覆盖 “不分层整体分析” 与 “分层精细化分析”，满足不同决策需求。

##### （一）不分层指标（全局视角）

|指标类别|核心指标|计算逻辑|
|---|---|---|
|概览指标|总发送次数、总核销次数、核销率、总优惠金额、总支付金额|核销率 = 总核销次数 / 总发送次数（需说明跨周期影响：如 17 日发送、18 日核销计入 18 日）|
|时间趋势指标|日 / 7 天 / 30 天的发送次数、核销次数、支付金额、核销率|按时间粒度聚合 DWS 层数据|
|活动效果指标|活动发送次数、核销率、支付金额、ROI（支付金额 / 优惠金额）|按活动 ID 分组聚合，支持降序排名|
|客服绩效指标|客服发送次数、核销率、平均优惠金额、人均支付金额|按客服 ID 分组聚合，评估客服转化能力|

##### （二）分层指标（精准视角）

在不分层指标基础上，按 RFM 用户分层进一步下钻：



|指标类别|核心指标|业务价值|
|---|---|---|
|分层概览指标|各分层的发送次数、核销率、支付金额占比|识别高价值用户贡献度，如 “高价值用户占比 20%，贡献 80% 支付金额”|
|分层活动效果指标|活动在各分层的核销率、优惠敏感度（支付金额 / 优惠金额）|评估活动对不同用户的吸引力，如 “流失用户对满 100 减 30 活动核销率最高”|
|分层客服绩效指标|客服在各分层的发送转化率（核销次数 / 发送次数）|识别擅长转化特定用户的客服，如 “客服 A 对潜力用户转化率达 35%，可推广其话术”|

#### 七、测试验证

通过多重测试确保数据可靠，支撑业务决策可信度。

##### （一）测试目标

- 验证 RFM 分层逻辑正确性（如 “总分 15 分用户是否被标记为高价值用户”）。
- 确保分层与不分层指标一致性（如 “分层总发送次数 = 不分层总发送次数”）。
- 校验业务规则适配性（如 “优惠金额≤5000 元”“有效期≤24 小时”）。

##### （二）核心测试用例（`test.py`）

python

```python
class TestRFMAndIndicators:
    def test_rfm_layer_logic(self, spark):
        """验证RFM分层逻辑：总分13分应判定为高价值用户"""
        test_data = spark.createDataFrame([
            ("user1", 5, 5, 3, 13),  # R=5, F=5, M=3 → 总分13
            ("user2", 2, 2, 1, 5)     # 总分5 → 流失用户
        ], ["consumer_id", "R_score", "F_score", "M_score", "rfm_total"])
        
        # 应用分层逻辑
        result = test_data.withColumn(
            "user_level",
            when(col("rfm_total") >12, "高价值用户")
            .when(col("rfm_total") >8, "潜力用户")
            .when(col("rfm_total") >5, "一般用户")
            .otherwise("流失用户")
        )
        
        # 断言：user1应为高价值用户，user2应为流失用户
        assert result.filter((col("consumer_id") == "user1") & (col("user_level") != "高价值用户")).count() == 0
        assert result.filter((col("consumer_id") == "user2") & (col("user_level") != "流失用户")).count() == 0

    def test_indicator_consistency(self, spark):
        """验证分层与不分层总发送次数一致性"""
        # 不分层总发送次数
        non_layered_total = spark.sql("SELECT sum(send_count) as total FROM ads_overview_non_layered").collect()[0]["total"]
        # 分层总发送次数（各分层求和）
        layered_total = spark.sql("SELECT sum(send_count) as total FROM ads_overview_layered").collect()[0]["total"]
        
        # 断言：两者差值应小于1（允许浮点误差）
        assert abs(non_layered_total - layered_total) < 1, "分层与不分层指标不一致"
```

##### （三）测试报告

输出 CSV 格式报告，包含测试 ID、名称、SQL、预期结果、实际结果、状态（通过 / 失败），便于追溯问题。

#### 八、应用场景与营销策略

结合 RFM 分层结果，设计差异化客服专属优惠策略，最大化优惠效果。



|用户分层|特征分析|优惠策略|预期效果|
|---|---|---|---|
|高价值用户|高频、高金额、高活跃|1. 自定义优惠（上限 5000 元，客服灵活调整）；  <br>2. 叠加私域权益（如会员日专属券、新品优先购）；  <br>3. 减少无意义打扰，仅推送高价值活动。|复购率提升 20%+，客单价提升 15%|
|潜力用户|高金额、中低频 / 低活跃|1. 固定优惠（如满 2000 减 300）+ 限时刺激（“24 小时内使用再减 50”）；  <br>2. 客服主动推送 “专属回购券”，附新品推荐。|消费频率提升 30%+|
|一般用户|中额、中低频|1. 小额立减券（如 10 元无门槛）+ 凑单引导（“再买 20 元减 15”）；  <br>2. 客服话术强调 “专属优惠仅限本次聊天”。|核销率提升 15%+|
|流失用户|低额、低频、长期未活跃|1. 高力度召回券（如满 100 减 30）+ 社群运营（拉入粉丝群领额外券）；  <br>2. 客服留言 “专属召回礼，点击领取”。|唤醒率提升 5%+|

#### 九、实施步骤

1. **环境配置**：安装 PySpark 3.2+、Python 3.8+，配置环境变量：

   python

    ```python
    import os
    os.environ["PYSPARK_PYTHON"] = "path/to/python.exe"
    os.environ["PYSPARK_DRIVER_PYTHON"] = "path/to/python.exe"
    ```

2. **数据生成**：运行`ods_csv.py`和`dws_csv.py`生成模拟数据（或接入真实业务数据）。

3. **数据处理**：依次执行`dim_csv.py`（维度表）→`dwd_csv.py`（明细处理）→`dws_csv.py`（汇总计算）。

4. **模型与指标**：运行`fen_bu.py`，生成 RFM 分层结果与核心指标（存入 ADS 层）。

5. **测试验证**：运行`test.py`，输出测试报告，修复异常数据 / 逻辑。

6. **策略落地**：分析 ADS 层指标，按 “用户分层 - 营销策略” 匹配表制定优惠活动，通过千牛工作台配置客服专属优惠。

7. **迭代优化**：每 7 天更新一次数据与模型，根据核销效果调整策略（如提高潜力用户的优惠力度）。




**总结**：本项目通过 RFM 模型实现用户精准分层，结合客服专属优惠的业务特性，构建了 “数据驱动 - 分层施策 - 效果闭环” 的营销体系，为电商商家提供可落地的增长方案。